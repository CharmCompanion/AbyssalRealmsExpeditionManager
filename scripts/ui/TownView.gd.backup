extends Control
# TownView.gd - Main town building and management view

const MAIN_MENU_SCENE: String = "res://scenes/ui/MainMenu.tscn"

const RunCode = preload("res://scripts/run/RunCode.gd")
const RunLog = preload("res://scripts/run/RunLog.gd")
const SimClock = preload("res://scripts/world/SimClock.gd")
const DungeonThreatSystem = preload("res://scripts/world/DungeonThreatSystem.gd")
const ExpeditionBoard = preload("res://scripts/world/ExpeditionBoard.gd")
const AutonomousExpeditions = preload("res://scripts/world/AutonomousExpeditions.gd")
const KingdomRegionTextureGenerator = preload("res://scripts/world/KingdomRegionTextureGenerator.gd")
const CharacterAppearanceRecipe = preload("res://scripts/appearance/CharacterAppearanceRecipe.gd")

const CivilianPlannerGOAP = preload("res://scripts/ai/town/CivilianPlannerGOAP.gd")
const EnemyBrainLimbo = preload("res://scripts/ai/enemy/EnemyBrainLimbo.gd")

# Character data (loaded from previous scene)
var lord_name: String = "Lord Unknown"
var town_name: String = "New Settlement"
var deity_name: String = "None"

var run_code: String = ""
var run_log_path: String = ""
var kingdom_id: int = 0

var _clock: SimClock
var _dungeons: DungeonThreatSystem
var _jobs: ExpeditionBoard
var _expeditions: AutonomousExpeditions

var _town_ai: CivilianPlannerGOAP
var _civilians: Array[Dictionary] = []
var _raid_root: Node

var sim_seconds_per_day: float = 30.0
var extra_dungeon_spawn_chance_per_day: float = 0.0

const BASE_SECONDS_PER_DAY: float = 30.0
const SPEED_STEPS: Array[int] = [1, 2, 5, 10]
var sim_speed_multiplier: int = 1

# Resource values
var gold: int = 500
var wood: int = 200
var stone: int = 150
var iron: int = 0
var food: int = 100
var population: int = 10

const TAB_BAR_WIDTH: float = 40.0
const TAB_TOGGLE_WIDTH: float = 18.0

const ACTION_SPEED_DOWN := "arx_speed_down"
const ACTION_SPEED_UP := "arx_speed_up"
const ACTION_PAUSE_TOGGLE := "arx_pause_toggle"
const ACTION_TABS_TOGGLE := "arx_tabs_toggle"
const ACTION_BUILD_MENU_TOGGLE := "arx_build_menu_toggle"

const ACTION_MENU_BUILD := "arx_menu_build"
const ACTION_MENU_LORD := "arx_menu_lord"
const ACTION_MENU_CITY := "arx_menu_city"
const ACTION_MENU_GUILD := "arx_menu_guild"
const ACTION_MENU_SETTINGS := "arx_menu_settings"

# Grid settings
const GRID_SIZE: int = 20  # 20x20 grid
const CELL_SIZE: float = 2.0  # 2 meters per cell

# Node references - Top bar
@onready var lord_name_value: Label = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/RightCenter/RightVBox/InfoCenter/InfoRow/LordValue
@onready var town_name_value: Label = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/RightCenter/RightVBox/InfoCenter/InfoRow/TownValue
@onready var deity_value: Label = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/RightCenter/RightVBox/InfoCenter/InfoRow/DeityValue

@onready var gold_value: Label = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/RightCenter/RightVBox/ResourcesCenter/ResourcesRow/GoldBox/Value
@onready var wood_value: Label = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/RightCenter/RightVBox/ResourcesCenter/ResourcesRow/WoodBox/Value
@onready var stone_value: Label = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/RightCenter/RightVBox/ResourcesCenter/ResourcesRow/StoneBox/Value
@onready var iron_value: Label = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/RightCenter/RightVBox/ResourcesCenter/ResourcesRow/IronBox/Value
@onready var food_value: Label = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/RightCenter/RightVBox/ResourcesCenter/ResourcesRow/FoodBox/Value
@onready var population_value: Label = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/RightCenter/RightVBox/ResourcesCenter/ResourcesRow/PopBox/Value

@onready var portrait_rig: Node2D = $PageContainer/ContentMargin/MainVBox/TopBarBackground/TopBarMargin/TopBarContent/PortraitFrame/PortraitMargin/PortraitContainer/PortraitViewport/PortraitRig

@onready var left_icon_bar: Control = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/LeftIconBar
@onready var tabs_toggle_btn: Button = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/TabsToggle
@onready var buildings_icon_btn: Button = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/LeftIconBar/IconMargin/IconCenter/IconVBox/BuildingsIcon

@onready var lord_icon_btn: Button = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/LeftIconBar/IconMargin/IconCenter/IconVBox/LordIcon
@onready var city_icon_btn: Button = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/LeftIconBar/IconMargin/IconCenter/IconVBox/CityIcon
@onready var guild_icon_btn: Button = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/LeftIconBar/IconMargin/IconCenter/IconVBox/GuildIcon
@onready var settings_icon_btn: Button = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/LeftIconBar/IconMargin/IconCenter/IconVBox/SettingsIcon

@onready var build_bar: Control = $PageContainer/BuildBar
@onready var build_bar_hbox: HBoxContainer = $PageContainer/BuildBar/BuildBarMargin/BuildBarScroll/BuildBarHBox

@onready var feature_popup: PanelContainer = $PageContainer/FeaturePopup
@onready var feature_title: Label = $PageContainer/FeaturePopup/FeatureMargin/FeatureVBox/FeatureTitle
@onready var feature_buttons: VBoxContainer = $PageContainer/FeaturePopup/FeatureMargin/FeatureVBox/FeatureButtons

# Time widget (bottom-right overlay)
@onready var time_value_label: Label = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/TimeWidget/TimeMargin/TimeHBox/TimeInfo/TimeValue
@onready var date_value_label: Label = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/TimeWidget/TimeMargin/TimeHBox/TimeInfo/DateValue
@onready var season_value_label: Label = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/TimeWidget/TimeMargin/TimeHBox/TimeInfo/SeasonValue

@onready var speed_slow_btn: Button = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/TimeWidget/TimeMargin/TimeHBox/TimeControls/Buttons/SlowBtn
@onready var speed_normal_btn: Button = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/TimeWidget/TimeMargin/TimeHBox/TimeControls/Buttons/NormalBtn
@onready var speed_fast_btn: Button = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/TimeWidget/TimeMargin/TimeHBox/TimeControls/Buttons/FastBtn

# Hover tooltip
@onready var hover_tooltip: PanelContainer = $PageContainer/HoverTooltip
@onready var tooltip_title: Label = $PageContainer/HoverTooltip/TooltipMargin/TooltipContent/TooltipTitle
@onready var tooltip_desc: Label = $PageContainer/HoverTooltip/TooltipMargin/TooltipContent/TooltipDesc
@onready var tooltip_cost: Label = $PageContainer/HoverTooltip/TooltipMargin/TooltipContent/TooltipCost
@onready var tooltip_benefit: Label = $PageContainer/HoverTooltip/TooltipMargin/TooltipContent/TooltipBenefit

@onready var town_scene: Node3D = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/CenterView/SubViewport/TownScene
@onready var grid_plane: MeshInstance3D = $PageContainer/ContentMargin/MainVBox/ContentHBox/MapLayer/CenterView/SubViewport/TownScene/GridPlane

var _tab_bar_open: bool = true
var _sim_paused: bool = false

var _build_buttons_by_name: Dictionary = {}

# Building data
var building_data = {
	"Academy": {
		"model": "res://assets/buildings/School.glb",
		"description": "A place of learning and research. Trains scholars and provides knowledge bonuses.",
		"cost": {"gold": 200, "wood": 100, "stone": 150},
		"upkeep": 10,
		"benefit": "+5 Knowledge per turn"
	},
	"Temple": {
		"model": "res://assets/buildings/Temple.glb",
		"description": "A sacred place of worship. Provides spiritual guidance and healing.",
		"cost": {"gold": 150, "wood": 80, "stone": 200},
		"upkeep": 8,
		"benefit": "+3 Faith, +2 Health per turn"
	},
	"Adventurer's Guild": {
		"model": "res://assets/buildings/Guild.glb",
		"description": "Headquarters for adventurers. Recruits heroes and manages expeditions.",
		"cost": {"gold": 250, "wood": 120, "stone": 100},
		"upkeep": 15,
		"benefit": "Recruit adventurers, +2 Quest capacity"
	},
	"Bank": {
		"model": "res://assets/buildings/Bank.glb",
		"description": "Manages town finances and trade. Increases gold income.",
		"cost": {"gold": 300, "wood": 50, "stone": 150},
		"upkeep": 12,
		"benefit": "+20 Gold per turn"
	},
	"Cottage": {
		"model": "res://assets/buildings/Cottage.glb",
		"description": "Simple housing for common folk. Increases population capacity.",
		"cost": {"gold": 50, "wood": 80, "stone": 30},
		"upkeep": 5,
		"benefit": "+10 Population capacity"
	},
	"Estate": {
		"model": "res://assets/buildings/Estate.glb",
		"description": "Housing for wealthy citizens. Attracts skilled workers.",
		"cost": {"gold": 150, "wood": 100, "stone": 80},
		"upkeep": 8,
		"benefit": "+5 Population, +2 Skilled workers"
	},
	"Lord's Manor": {
		"model": "res://assets/buildings/Manor.glb",
		"description": "Luxurious residence for nobility. Increases town prestige significantly.",
		"cost": {"gold": 400, "wood": 150, "stone": 250},
		"upkeep": 20,
		"benefit": "+10 Prestige, +5% Tax income"
	}
}

var selected_building: String = ""

func _ready() -> void:
	print("[TownView] _ready")
	_ensure_default_hotkeys()
	_load_save_data()
	_sim_speed_sync_from_seconds()
	_apply_lord_portrait_from_run_code()
	_create_grid_plane()
	_update_all_displays()
	_connect_buttons()
	_setup_sim_systems()
	_connect_left_icons()
	_connect_tab_toggle()
	_set_tab_bar_open(true, false)
	_update_time_widget()
	set_process_unhandled_input(true)


func _ensure_default_hotkeys() -> void:
	# Runtime defaults so the game works immediately; later you can move these into ProjectSettings/InputMap.
	_ensure_key_action(ACTION_SPEED_DOWN, [KEY_LEFT, KEY_KP_SUBTRACT])
	_ensure_key_action(ACTION_SPEED_UP, [KEY_RIGHT, KEY_KP_ADD])
	_ensure_key_action(ACTION_PAUSE_TOGGLE, [KEY_P])
	# Tab-column toggles.
	_ensure_key_action(ACTION_TABS_TOGGLE, [KEY_TAB, KEY_T])
	# Bottom build menu (same as clicking the buildings icon).
	_ensure_key_action(ACTION_BUILD_MENU_TOGGLE, [KEY_B])

	# Quick open menus (category icons).
	_ensure_key_action(ACTION_MENU_BUILD, [KEY_F1])
	_ensure_key_action(ACTION_MENU_LORD, [KEY_F2])
	_ensure_key_action(ACTION_MENU_CITY, [KEY_F3])
	_ensure_key_action(ACTION_MENU_GUILD, [KEY_F4])
	_ensure_key_action(ACTION_MENU_SETTINGS, [KEY_F5])


func _ensure_key_action(action_name: String, keycodes: Array[int]) -> void:
	if not InputMap.has_action(action_name):
		InputMap.add_action(action_name)
	for code in keycodes:
		var ev: InputEventKey = InputEventKey.new()
		ev.keycode = code
		# Avoid duplicates.
		var already: bool = false
		for existing: InputEvent in InputMap.action_get_events(action_name):
			if existing is InputEventKey and (existing as InputEventKey).keycode == code:
				already = true
				break
		if not already:
			InputMap.action_add_event(action_name, ev)


func _connect_left_icons() -> void:
	if buildings_icon_btn != null:
		buildings_icon_btn.pressed.connect(func() -> void:
			if build_bar != null:
				build_bar.visible = not build_bar.visible
		)
	if lord_icon_btn != null:
		lord_icon_btn.pressed.connect(func() -> void:
			_open_menu("lord")
		)
	if city_icon_btn != null:
		city_icon_btn.pressed.connect(func() -> void:
			_open_menu("city")
		)
	if guild_icon_btn != null:
		guild_icon_btn.pressed.connect(func() -> void:
			_open_menu("guild")
		)
	if settings_icon_btn != null:
		settings_icon_btn.pressed.connect(func() -> void:
			_open_menu("settings")
		)


func _open_menu(menu_id: String) -> void:
	# Always bring the tab bar out when opening a menu.
	_set_tab_bar_open(true, true)
	if menu_id == "build":
		if build_bar != null:
			build_bar.visible = true
		return
	_show_feature_popup(menu_id)


func _show_feature_popup(menu_id: String) -> void:
	if feature_popup == null or feature_title == null or feature_buttons == null:
		return

	# Toggle off if same menu is already open.
	if feature_popup.visible and String(feature_popup.get_meta("menu_id", "")) == menu_id:
		feature_popup.visible = false
		return

	feature_popup.set_meta("menu_id", menu_id)
	feature_popup.visible = true

	for c in feature_buttons.get_children():
		c.queue_free()

	var title: String = "Menu"
	var labels: Array[String] = []
	var actions: Array[String] = []

	match menu_id:
		"lord":
			title = "Lord Management"
			labels = ["Lord Overview", "Powers", "Edicts", "Diplomacy"]
			actions = ["lord_overview", "lord_powers", "lord_edicts", "lord_diplomacy"]
		"city":
			title = "City Management"
			labels = ["City Overview", "Buildings (Placement)", "Economy", "Population"]
			actions = ["city_overview", "build_open", "city_economy", "city_population"]
		"guild":
			title = "Institutions"
			labels = ["Adventurer's Guild", "Academy", "Temple", "Bank"]
			actions = ["inst_guild", "inst_academy", "inst_temple", "inst_bank"]
		"settings":
			title = "Game"
			labels = ["Settings", "Save/Load", "Return to Main Menu"]
			actions = ["game_settings", "game_save_load", "game_main_menu"]
		_:
			title = "Menu"
			labels = ["Coming soon"]
			actions = ["noop"]

	feature_title.text = title
	for i in range(labels.size()):
		var b: Button = Button.new()
		b.text = labels[i]
		b.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		b.pressed.connect(_on_feature_action_pressed.bind(actions[i]))
		feature_buttons.add_child(b)


func _on_feature_action_pressed(action_id: String) -> void:
	match action_id:
		"build_open":
			if build_bar != null:
				build_bar.visible = true
			# Keep the feature popup open; it functions as a hub.
		"game_main_menu":
			get_tree().change_scene_to_file(MAIN_MENU_SCENE)
		"noop":
			pass
		_:
			# Placeholder hooks for future windows.
			pass


func _connect_tab_toggle() -> void:
	if tabs_toggle_btn == null:
		return
	# Ensure we only connect once in case of hot reload.
	var cb := Callable(self, "_on_tabs_toggle_pressed")
	if not tabs_toggle_btn.pressed.is_connected(cb):
		tabs_toggle_btn.pressed.connect(cb)


func _on_tabs_toggle_pressed() -> void:
	_set_tab_bar_open(not _tab_bar_open, true)


func _set_tab_bar_open(open: bool, animated: bool) -> void:
	_tab_bar_open = open
	if left_icon_bar == null or tabs_toggle_btn == null:
		return

	var x := 0.0 if open else -TAB_BAR_WIDTH
	var btn_x := TAB_BAR_WIDTH if open else 0.0
	# Flip direction based on open/closed.
	tabs_toggle_btn.text = "◀" if open else "▶"

	if animated:
		var t := create_tween()
		t.set_trans(Tween.TRANS_SINE)
		t.set_ease(Tween.EASE_OUT)
		t.tween_property(left_icon_bar, "offset_left", x, 0.15)
		t.parallel().tween_property(left_icon_bar, "offset_right", x + TAB_BAR_WIDTH, 0.15)
		t.parallel().tween_property(tabs_toggle_btn, "offset_left", btn_x, 0.15)
		t.parallel().tween_property(tabs_toggle_btn, "offset_right", btn_x + TAB_TOGGLE_WIDTH, 0.15)
	else:
		left_icon_bar.offset_left = x
		left_icon_bar.offset_right = x + TAB_BAR_WIDTH
		tabs_toggle_btn.offset_left = btn_x
		tabs_toggle_btn.offset_right = btn_x + TAB_TOGGLE_WIDTH


func _populate_build_bar() -> void:
	if build_bar_hbox == null:
		return

	for c in build_bar_hbox.get_children():
		c.queue_free()
	_build_buttons_by_name.clear()

	# Minimal, deterministic ordering.
	var ordered: Array[String] = [
		"Academy",
		"Temple",
		"Adventurer's Guild",
		"Bank",
		"Cottage",
		"Estate",
		"Lord's Manor",
	]
	for building_name in ordered:
		if not building_data.has(building_name):
			continue
		var b := Button.new()
		b.custom_minimum_size = Vector2(140, 0)
		b.text = building_name
		b.pressed.connect(_on_building_clicked.bind(building_name))
		b.mouse_entered.connect(_on_building_hover.bind(building_name))
		b.mouse_exited.connect(_on_building_unhover)
		build_bar_hbox.add_child(b)
		_build_buttons_by_name[building_name] = b


func _apply_lord_portrait_from_run_code() -> void:
	if portrait_rig == null:
		return
	if run_code.strip_edges() == "":
		return
	if not RunCode.is_run_code(run_code):
		return

	var settings := RunCode.decode(run_code)
	if settings.is_empty():
		return
	var la: Dictionary = Dictionary(settings.get("lord_appearance", {}))
	if la.is_empty():
		return
	var recipe := CharacterAppearanceRecipe.from_dict(la)
	recipe.apply_to(portrait_rig)
	if portrait_rig.has_method("set_action"):
		portrait_rig.call("set_action", "Idle")


func _load_save_data() -> void:
	var path := "user://savegame.json"
	if not FileAccess.file_exists(path):
		return
	var f := FileAccess.open(path, FileAccess.READ)
	if f == null:
		return
	var txt := f.get_as_text()
	f.close()
	var v: Variant = JSON.parse_string(txt)
	if typeof(v) != TYPE_DICTIONARY:
		return
	var d: Dictionary = v

	lord_name = String(d.get("lord_name", lord_name))
	town_name = String(d.get("town_name", town_name))
	kingdom_id = int(d.get("kingdom_id", kingdom_id))
	run_code = String(d.get("run_code", run_code))
	run_log_path = String(d.get("run_log_path", run_log_path))

	# Seed can be numeric or derived from run_code.
	if run_code.strip_edges() != "" and RunCode.is_run_code(run_code):
		# Keep using the derived numeric seed for determinism.
		var derived := RunCode.seed_from_code(run_code)
		# Nothing else currently stores this, but you may want it later.
		# (We still keep the saved numeric seed too.)
		pass

	# World settings.
	var world: Dictionary = Dictionary(d.get("world_settings", {}))
	extra_dungeon_spawn_chance_per_day = float(world.get("extra_dungeon_spawn_chance_per_day", extra_dungeon_spawn_chance_per_day))

	# Load resources if present.
	gold = int(d.get("gold", gold))
	wood = int(d.get("wood", wood))
	stone = int(d.get("stone", stone))
	iron = int(d.get("ore", d.get("iron", iron)))
	food = int(d.get("food", food))
	population = int(d.get("population", population))

	# Deity
	deity_name = String(d.get("deity_name", deity_name))

	# Sim speed preference (pacing only).
	sim_seconds_per_day = float(d.get("sim_seconds_per_day", sim_seconds_per_day))


func _setup_sim_systems() -> void:
	# Minimal sim loop: advance "days" on a real-time clock.
	# You can later expose speed controls, pause, etc.
	_clock = SimClock.new()
	_clock.seconds_per_day = sim_seconds_per_day
	add_child(_clock)

	_dungeons = DungeonThreatSystem.new()
	# Start with a few dungeons per kingdom (Zeus-like: persistent pressure sources).
	_dungeons.dungeons_per_kingdom = 3
	# Optional extra dungeons over time. Default off (0.0) to avoid overwhelming players.
	_dungeons.extra_dungeon_spawn_chance_per_day = extra_dungeon_spawn_chance_per_day
	add_child(_dungeons)

	_jobs = ExpeditionBoard.new()
	_jobs.jobs_per_board = 4
	_jobs.board_refresh_days = 3
	add_child(_jobs)

	_expeditions = AutonomousExpeditions.new()
	_expeditions.expedition_interval_days = 2
	add_child(_expeditions)

	var base_seed := 0
	if RunCode.is_run_code(run_code):
		base_seed = int(RunCode.seed_from_code(run_code))
	else:
		base_seed = int(RunCode.seed_from_code("fallback:" + str(kingdom_id) + "|" + town_name))
	_dungeons.setup(run_code, run_log_path, base_seed, kingdom_id)
	_jobs.setup(run_code, run_log_path, base_seed)
	_expeditions.setup(run_code, run_log_path, base_seed)

	_clock.day_advanced.connect(_on_day_advanced)

	_expeditions.expedition_report.connect(_on_expedition_report)
	_dungeons.raid_arrival.connect(_on_raid_arrival)

	_connect_speed_buttons()
	_apply_speed_visuals()
	_update_time_widget()

	_setup_town_ai()


func _on_day_advanced(day: int) -> void:
	_dungeons.on_day(day)
	_jobs.on_day(day, _dungeons.sites, _town_state_snapshot())
	_expeditions.on_day(day, _jobs.jobs, _dungeons, _town_state_snapshot())
	_update_time_widget()
	# Run town AI as a separate coroutine (GOAP planning uses await internally).
	call_deferred("_run_town_ai_for_day", day)


func _update_time_widget() -> void:
	if time_value_label == null or date_value_label == null or season_value_label == null:
		return
	var day_index := 0
	if _clock != null:
		day_index = _clock.day

	# Simple calendar model: 30-day months, 12 months/year.
	var day_of_month := int(day_index % 30) + 1
	var month := int((day_index / 30) % 12) + 1
	var year := int(day_index / 360) + 1

	var season_names: Array[String] = ["Spring", "Summer", "Autumn", "Winter"]
	var season := season_names[int((month - 1) / 3) % 4]

	time_value_label.text = "Time: Day %d" % (day_index + 1)
	date_value_label.text = "%02d/%02d/%04d" % [day_of_month, month, year]
	season_value_label.text = season
	_apply_speed_visuals()


func _sim_speed_sync_from_seconds() -> void:
	# Align to the closest supported multiplier.
	if sim_seconds_per_day <= 0.0:
		sim_seconds_per_day = BASE_SECONDS_PER_DAY
	var approx: float = BASE_SECONDS_PER_DAY / sim_seconds_per_day
	var best: int = 1
	var best_diff: float = 999999.0
	for m: int in SPEED_STEPS:
		var diff: float = absf(float(m) - approx)
		if diff < best_diff:
			best_diff = diff
			best = m
	sim_speed_multiplier = best
	sim_seconds_per_day = BASE_SECONDS_PER_DAY / float(sim_speed_multiplier)


func _step_sim_speed(direction: int) -> void:
	# direction: -1 (slower), +1 (faster)
	var idx := SPEED_STEPS.find(sim_speed_multiplier)
	if idx == -1:
		idx = 0
	var next_idx := clampi(idx + direction, 0, SPEED_STEPS.size() - 1)
	# No wrap: if you're at x10, you must press slow to go back down.
	if next_idx == idx:
		_apply_speed_visuals()
		return
	sim_speed_multiplier = SPEED_STEPS[next_idx]
	_set_sim_speed_seconds(BASE_SECONDS_PER_DAY / float(sim_speed_multiplier), "x%d" % sim_speed_multiplier)


func _setup_town_ai() -> void:
	_town_ai = CivilianPlannerGOAP.new()
	_town_ai.enabled = true
	_town_ai.setup(run_code, run_log_path)
	add_child(_town_ai)
	_init_civilian_ai()


func _init_civilian_ai() -> void:
	_civilians.clear()
	var count := mini(population, 10)
	if count <= 0:
		return
	var rng := RandomNumberGenerator.new()
	var seed := int(RunCode.seed_from_code(run_code + "|town_ai_init")) if RunCode.is_run_code(run_code) else int(RunCode.seed_from_code("fallback|town_ai_init"))
	rng.seed = seed
	for i in range(count):
		_civilians.append({
			"id": "civ_%d" % i,
			"hunger": rng.randf_range(0.0, 0.6),
			"rest_need": rng.randf_range(0.0, 0.6),
			"is_sheltered": false,
		})


func _run_town_ai_for_day(_day: int) -> void:
	if _town_ai == null or _civilians.is_empty():
		return

	var danger := _compute_town_danger()

	for i in range(_civilians.size()):
		var s: Dictionary = _civilians[i]
		# Basic needs drift upward each day.
		s["hunger"] = clampf(float(s.get("hunger", 0.0)) + 0.15, 0.0, 1.0)
		s["rest_need"] = clampf(float(s.get("rest_need", 0.0)) + 0.10, 0.0, 1.0)
		if danger < 0.5:
			s["is_sheltered"] = false

		var result: Dictionary = await _town_ai.choose_goal(s, {"danger": danger})
		var goal := String(result.get("goal", "idle"))
		# Apply a tiny amount of state change to reflect the chosen goal.
		if goal == "Seek Shelter":
			s["is_sheltered"] = true
		elif goal == "Eat":
			s["hunger"] = clampf(float(s.get("hunger", 0.0)) - 0.6, 0.0, 1.0)
		elif goal == "Rest":
			s["rest_need"] = clampf(float(s.get("rest_need", 0.0)) - 0.7, 0.0, 1.0)

		_civilians[i] = s


func _compute_town_danger() -> float:
	if _dungeons == null or _dungeons.sites.is_empty():
		return 0.0
	var sum := 0.0
	for s in _dungeons.sites:
		sum += float(s.get("threat", 0.0))
	return clampf((sum / float(_dungeons.sites.size())) / 100.0, 0.0, 1.0)


func _on_raid_arrival(raid: Dictionary) -> void:
	# Minimal integration: spawn a small set of enemy nodes and attach LimboAI brains.
	var enemy_count := maxi(1, int(raid.get("enemy_count", 5)))
	var spawn_count := mini(enemy_count, 12)
	if _raid_root == null:
		_raid_root = Node.new()
		_raid_root.name = "RaidEnemies"
		add_child(_raid_root)

	for i in range(spawn_count):
		var enemy := Node.new()
		enemy.name = "RaidEnemy_%s_%d" % [String(raid.get("site_id", "site")), i]
		_raid_root.add_child(enemy)
		var brain := EnemyBrainLimbo.new()
		brain.setup(run_code, run_log_path)
		brain.enabled = true
		brain.behavior_resource_path = "res://ai/behaviors/raid_enemy_bt.tres"
		enemy.add_child(brain)
		brain.ensure_started()


func _connect_speed_buttons() -> void:
	if speed_slow_btn != null:
		speed_slow_btn.pressed.connect(func() -> void:
			_step_sim_speed(-1)
		)
	if speed_normal_btn != null:
		speed_normal_btn.pressed.connect(func() -> void:
			_toggle_pause_or_play()
		)
	if speed_fast_btn != null:
		speed_fast_btn.pressed.connect(func() -> void:
			_step_sim_speed(1)
		)


func _toggle_pause_or_play() -> void:
	_sim_paused = not _sim_paused
	if _clock != null:
		_clock.set_process(not _sim_paused)
	_apply_speed_visuals()


func _set_sim_speed_seconds(seconds_per_day: float, speed_id: String) -> void:
	# Selecting a speed should implicitly unpause.
	if _sim_paused:
		_sim_paused = false
		if _clock != null:
			_clock.set_process(true)
	sim_seconds_per_day = maxf(0.1, seconds_per_day)
	if _clock != null:
		_clock.seconds_per_day = sim_seconds_per_day
	_sim_speed_sync_from_seconds()
	_apply_speed_visuals()
	_save_game_pacing()
	if run_log_path.strip_edges() != "":
		RunLog.log_choice_to(run_log_path, run_code, int(RunCode.seed_from_code(run_code)) if RunCode.is_run_code(run_code) else 0, "sim_speed", {
			"speed_id": speed_id,
			"seconds_per_day": sim_seconds_per_day,
		})


func _apply_speed_visuals() -> void:
	# Minimal visual feedback: disable the active speed button.
	# Middle button is play/pause, so keep it enabled.
	if speed_slow_btn != null:
		speed_slow_btn.disabled = sim_speed_multiplier <= 1
	if speed_normal_btn != null:
		speed_normal_btn.disabled = false
	if speed_fast_btn != null:
		speed_fast_btn.disabled = sim_speed_multiplier >= 10


func _unhandled_input(event: InputEvent) -> void:
	if feature_popup != null and feature_popup.visible and Input.is_action_just_pressed("ui_cancel"):
		feature_popup.visible = false
		get_viewport().set_input_as_handled()
		return

	if Input.is_action_just_pressed(ACTION_SPEED_DOWN):
		_step_sim_speed(-1)
		get_viewport().set_input_as_handled()
		return
	if Input.is_action_just_pressed(ACTION_SPEED_UP):
		_step_sim_speed(1)
		get_viewport().set_input_as_handled()
		return
	if Input.is_action_just_pressed(ACTION_PAUSE_TOGGLE):
		_toggle_pause_or_play()
		get_viewport().set_input_as_handled()
		return
	if Input.is_action_just_pressed(ACTION_TABS_TOGGLE):
		_on_tabs_toggle_pressed()
		get_viewport().set_input_as_handled()
		return
	if Input.is_action_just_pressed(ACTION_BUILD_MENU_TOGGLE):
		if build_bar != null:
			build_bar.visible = not build_bar.visible
			# If they open the build menu via hotkey, ensure the tab bar is visible too.
			if build_bar.visible:
				_set_tab_bar_open(true, true)
		get_viewport().set_input_as_handled()
		return

	if Input.is_action_just_pressed(ACTION_MENU_BUILD):
		_open_menu("build")
		get_viewport().set_input_as_handled()
		return
	if Input.is_action_just_pressed(ACTION_MENU_LORD):
		_open_menu("lord")
		get_viewport().set_input_as_handled()
		return
	if Input.is_action_just_pressed(ACTION_MENU_CITY):
		_open_menu("city")
		get_viewport().set_input_as_handled()
		return
	if Input.is_action_just_pressed(ACTION_MENU_GUILD):
		_open_menu("guild")
		get_viewport().set_input_as_handled()
		return
	if Input.is_action_just_pressed(ACTION_MENU_SETTINGS):
		_open_menu("settings")
		get_viewport().set_input_as_handled()
		return


func _save_game_pacing() -> void:
	var path := "user://savegame.json"
	if not FileAccess.file_exists(path):
		return
	var f := FileAccess.open(path, FileAccess.READ)
	if f == null:
		return
	var txt := f.get_as_text()
	f.close()
	var v: Variant = JSON.parse_string(txt)
	if typeof(v) != TYPE_DICTIONARY:
		return
	var d: Dictionary = v
	d["sim_seconds_per_day"] = sim_seconds_per_day
	var wf: FileAccess = FileAccess.open(path, FileAccess.WRITE)
	if wf != null:
		wf.store_string(JSON.stringify(d, "\t"))
		wf.close()


func _town_state_snapshot() -> Dictionary:
	return {
		"gold": gold,
		"wood": wood,
		"stone": stone,
		"iron": iron,
		"food": food,
		"population": population,
		"town_name": town_name,
		"kingdom_id": kingdom_id,
	}


func _on_expedition_report(report: Dictionary) -> void:
	var loot: Dictionary = Dictionary(report.get("loot", {}))
	gold += int(loot.get("gold", 0))
	food += int(loot.get("food", 0))
	wood += int(loot.get("wood", 0))
	stone += int(loot.get("stone", 0))
	iron += int(loot.get("ore", loot.get("iron", 0)))

	# Treat deaths as population loss (simple model for now).
	population = max(0, population - int(report.get("deaths", 0)))

	_update_resource_display()
	_save_game_state()


func _save_game_state() -> void:
	var path := "user://savegame.json"
	if not FileAccess.file_exists(path):
		return
	var f := FileAccess.open(path, FileAccess.READ)
	if f == null:
		return
	var txt := f.get_as_text()
	f.close()
	var v: Variant = JSON.parse_string(txt)
	if typeof(v) != TYPE_DICTIONARY:
		return
	var d: Dictionary = v
	d["gold"] = gold
	d["food"] = food
	d["wood"] = wood
	d["stone"] = stone
	d["ore"] = iron
	d["population"] = population

	# Preserve world settings and pacing.
	d["sim_seconds_per_day"] = sim_seconds_per_day
	var wf: FileAccess = FileAccess.open(path, FileAccess.WRITE)
	if wf != null:
		wf.store_string(JSON.stringify(d, "\t"))
		wf.close()

func _update_all_displays() -> void:
	# Update lord/town info
	lord_name_value.text = lord_name
	town_name_value.text = town_name
	deity_value.text = deity_name
	
	# Update resources
	_update_resource_display()

func _update_resource_display() -> void:
	gold_value.text = str(gold)
	wood_value.text = str(wood)
	stone_value.text = str(stone)
	iron_value.text = str(iron)
	food_value.text = str(food)
	population_value.text = str(population)

func _create_grid_plane() -> void:
	# Create a plane mesh with a deterministic region texture (kingdom-based).
	var plane_mesh := PlaneMesh.new()
	plane_mesh.size = Vector2(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE)
	plane_mesh.subdivide_width = GRID_SIZE
	plane_mesh.subdivide_depth = GRID_SIZE
	
	grid_plane.mesh = plane_mesh
	
	# Create material with grid lines
	var material := StandardMaterial3D.new()
	material.albedo_color = Color(0.85, 0.82, 0.7, 1.0)  # Parchment color
	material.metallic = 0.0
	material.roughness = 1.0
	
	# Create region texture (biome/kingdom-driven).
	var base_seed: int = 0
	if RunCode.is_run_code(run_code):
		base_seed = int(RunCode.seed_from_code(run_code + "|region"))
	else:
		base_seed = int(RunCode.seed_from_code("fallback|region|" + str(kingdom_id) + "|" + town_name))
	var region_texture: ImageTexture
	if KingdomRegionTextureGenerator.can_generate_isometric_tiles():
		region_texture = KingdomRegionTextureGenerator.generate_isometric_region_texture(
			GRID_SIZE,
			base_seed,
			kingdom_id
		)
	else:
		region_texture = KingdomRegionTextureGenerator.generate_region_texture(
			GRID_SIZE,
			16,
			base_seed,
			kingdom_id
		)
	material.albedo_texture = region_texture
	material.uv1_scale = Vector3(1, 1, 1)
	
	grid_plane.material_override = material
	
	print("[TownView] Created ", GRID_SIZE, "x", GRID_SIZE, " region map (kingdom_id=", kingdom_id, ")")

func _create_grid_texture() -> ImageTexture:
	# Create a small texture with grid lines
	var img := Image.create(64, 64, false, Image.FORMAT_RGBA8)
	img.fill(Color(0.85, 0.82, 0.7, 1.0))  # Base parchment color
	
	# Draw grid lines
	var grid_color := Color(0.6, 0.55, 0.4, 1.0)  # Darker brown for lines
	for x in range(64):
		img.set_pixel(x, 0, grid_color)
		img.set_pixel(x, 63, grid_color)
	for y in range(64):
		img.set_pixel(0, y, grid_color)
		img.set_pixel(63, y, grid_color)
	
	var texture := ImageTexture.create_from_image(img)
	return texture

func _connect_buttons() -> void:
	_populate_build_bar()

func _on_building_hover(building_name: String) -> void:
	var data = building_data[building_name]
	tooltip_title.text = building_name
	tooltip_desc.text = data["description"]
	
	var cost_str = "Cost: "
	if data["cost"].has("gold"): cost_str += str(data["cost"]["gold"]) + "g "
	if data["cost"].has("wood"): cost_str += str(data["cost"]["wood"]) + "w "
	if data["cost"].has("stone"): cost_str += str(data["cost"]["stone"]) + "s"
	tooltip_cost.text = cost_str
	
	tooltip_benefit.text = "Benefit: " + data["benefit"]
	hover_tooltip.visible = true

func _on_building_unhover() -> void:
	hover_tooltip.visible = false

func _on_building_clicked(building_name: String) -> void:
	selected_building = building_name
	var data = building_data[building_name]
	
	# Check if player can afford
	var can_afford = true
	if data["cost"].has("gold") and gold < data["cost"]["gold"]: can_afford = false
	if data["cost"].has("wood") and wood < data["cost"]["wood"]: can_afford = false
	if data["cost"].has("stone") and stone < data["cost"]["stone"]: can_afford = false
	
	if not can_afford:
		print("[TownView] Cannot afford ", building_name)
		return
	
	# Deduct resources
	if data["cost"].has("gold"): gold -= data["cost"]["gold"]
	if data["cost"].has("wood"): wood -= data["cost"]["wood"]
	if data["cost"].has("stone"): stone -= data["cost"]["stone"]
	
	_update_resource_display()
	
	# Load and place building model
	var building_scene = load(data["model"])
	if building_scene:
		var building_instance = building_scene.instantiate()
		town_scene.add_child(building_instance)
		# Position at grid center for now (TODO: implement drag & drop)
		building_instance.position = Vector3(0, 0, 0)
		print("[TownView] Placed building: ", selected_building)
